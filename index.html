<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Browser-based Music Editor</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; background-color: #fff; color: #000; }
  body.dark-mode { background-color: #333; color: #fff; }
  #header { display: flex; align-items: center; margin-bottom: 10px; }
  #header input[type=number] { width: 60px; margin-right: 10px; }
  #header button { margin-right: 10px; }
  #dark-mode-toggle { cursor: pointer; font-size: 24px; margin-right: 15px; }
  input[type="color"] { border: 1px solid #000; }

  #music-table { border-collapse: collapse; width: 100%; }
  #music-table th, #music-table td { border: 1px solid #ccc; padding: 5px; }
  #music-table th:first-child,
  #music-table td:first-child {
    position: sticky;
    left: 0;
    z-index: 1;
  }
  #music-table th:first-child {
    background-color: #f2f2f2;
  }
  body.dark-mode #music-table th:first-child {
    background-color: #444;
  }
  .instrument-col { display: flex; align-items: center; gap: 5px; }
  .track-label { color: #000; white-space: nowrap; }
  .track-label-input-container { display: flex; align-items: center; gap: 5px; }
  .timeline-col {
    position: relative; 
    height: 42px; /* track height */
    background-image: linear-gradient(to right, #ccc 1px, transparent 1px), linear-gradient(to bottom, #ccc 1px, transparent 1px);
    background-size: 30px 100%, 100% 21px;
    border-bottom: 2px solid #ccc;
    box-sizing: border-box;
  }
  body.dark-mode .timeline-col {
    background-image: linear-gradient(to right, #555 1px, transparent 1px), linear-gradient(to bottom, #555 1px, transparent 1px);
    border-bottom-color: #555;
  }
  .note {
    position: absolute; height: 70%;
    top: 15%;
    background: lightblue; border: 1px solid blue;
    box-sizing: border-box; cursor: move;
    display: flex; align-items: center; justify-content: center;
    color: black;
  }
  .resize-handle {
    position: absolute;
    top: 0;
    width: 5px;
    height: 100%;
    background: rgba(0,0,0,0.5);
    cursor: ew-resize;
  }
  .resize-handle.left { left: 0; }
  .resize-handle.right { right: 0; }
  .delete-note {
    position: absolute; top: -15px; right: 2px;
    font-weight: bold; cursor: pointer;
    color: #000;
  }
  .edit-note {
    position: absolute; top: -15px; left: 2px;
    cursor: pointer;
    color: #000;
  }
  body.dark-mode .delete-note, body.dark-mode .edit-note {
    color: #fff;
  }
  #duration-tooltip {
    position: fixed;
    background: #fff;
    border: 1px solid #000;
    padding: 2px 5px;
    font-size: 12px;
    display: none;
    color: #000;
  }
  .indented .instrument-col {
    margin-left: 20px;
  }
  .indented .link-btn { display: none; }
    .unlink-btn { display: none; }
    .indented .unlink-btn { display: inline-block; }
    .drag-handle {
      cursor: grab;
      padding: 0 5px;
      user-select: none;
      color: #000;
    }
  </style>
</head>
<body>
<div id="header">
  <span id="dark-mode-toggle">ðŸŒ“</span>
  Tempo (1/unit): <input type="number" id="tempoInput" value="1" min="1" step="1">
  <button id="addTrackBtn">Add Track</button>
  <button id="exportBtn">Export</button>
  <button id="importBtn">Import</button>
  <button id="resetBtn">Reset</button>
  <label for="zoomSlider" style="margin-left: 10px;">Zoom:</label>
  <input type="range" id="zoomSlider" min="0" max="100" value="25" style="vertical-align: middle;">
  <div id="pasteLink"></div>
</div>

<div style="overflow-x: auto; padding-bottom: 20px;">
<table id="music-table">
  <thead>
    <tr>
      <th>Instrument</th>
      <th>Timeline</th>
    </tr>
  </thead>
  <tbody>
    <!-- Dynamic track rows will be added here -->
  </tbody>
</table>
</div>

<div id="duration-tooltip"></div>

<script>
const darkModeToggle = document.getElementById('dark-mode-toggle');
const body = document.body;

body.classList.add('dark-mode');

darkModeToggle.addEventListener('click', () => {
    body.classList.toggle('dark-mode');
});

let tracks = [];
let baseStepWidth = 30;
let stepWidth = baseStepWidth;
let trackCount = 0;
let tempo = 1;
let zoomLevel = 25; // Default zoom level

document.getElementById('addTrackBtn').addEventListener('click', () => addTrack());
document.getElementById('exportBtn').addEventListener('click', exportTracks);
document.getElementById('importBtn').addEventListener('click', importTracks);
document.getElementById('tempoInput').addEventListener('input', updateTempo);
document.getElementById('resetBtn').addEventListener('click', () => {
    if (confirm('Are you sure you want to delete all tracks and notes?')) {
        localStorage.removeItem('musicMakerState');
        location.reload();
    }
});

function saveState() {
    const state = {
        tempo: tempo,
        tracks: tracks.map(track => ({
            name: track.name,
            color: track.color,
            groupId: track.groupId,
            isLinked: track.isLinked,
            timelineMinWidth: track.timeline.style.minWidth,
            notes: track.isLinked ? null : track.notes.map(note => ({
                start: note.start,
                duration: note.duration
            }))
        }))
    };
    localStorage.setItem('musicMakerState', JSON.stringify(state));
}

function loadState() {
    const savedStateJSON = localStorage.getItem('musicMakerState');

    if (!savedStateJSON) {
        addTrack(); // Creates and saves a default track
    } else {
        const savedState = JSON.parse(savedStateJSON);

        // Clear default state
        document.querySelector('#music-table tbody').innerHTML = '';
        tracks = [];
        trackCount = 0;

        document.getElementById('tempoInput').value = savedState.tempo || 1;
        tempo = savedState.tempo || 1;

        const parentTrackMap = new Map();

        savedState.tracks.forEach(savedTrack => {
            let trackToProcess;

            if (savedTrack.isLinked) {
                const parent = parentTrackMap.get(savedTrack.groupId);
                if (!parent) return;

                const originalIndex = tracks.indexOf(parent);
                trackToProcess = addTrack(parent, true, true);
                trackToProcess.groupId = parent.groupId;

                tracks.splice(tracks.indexOf(trackToProcess), 1);
                tracks.splice(originalIndex + 1, 0, trackToProcess);

                trackToProcess.isLinked = true;
                trackToProcess.notes = parent.notes;
                trackToProcess.notes.forEach(note => createNoteElement(trackToProcess, note));
            } else {
                trackToProcess = addTrack(null, false, true);
                parentTrackMap.set(savedTrack.groupId, trackToProcess);

                savedTrack.notes.forEach(savedNote => {
                    const note = { start: savedNote.start, duration: savedNote.duration, elements: [] };
                    trackToProcess.notes.push(note);
                    createNoteElement(trackToProcess, note);
                });
            }

            trackToProcess.name = savedTrack.name;
            trackToProcess.input.value = savedTrack.name;
            trackToProcess.color = savedTrack.color;
            trackToProcess.groupId = savedTrack.groupId;
            if (savedTrack.timelineMinWidth) {
                trackToProcess.timeline.style.minWidth = savedTrack.timelineMinWidth;
            }
        });

        const tbody = document.querySelector('#music-table tbody');
        tracks.forEach(t => tbody.appendChild(t.elem));

        updateTrackLabels();
        updateTrackStyles();
        updateTrackColors();
        redrawAllNotes();
    }

    // After loading or creating the initial track, set the default zoom without saving state.
    const slider = document.getElementById('zoomSlider');
    slider.value = 25;
    zoomLevel = 25;

    const minStepWidth = 8.33;
    const maxStepWidth = 100;
    stepWidth = minStepWidth + (zoomLevel / 100) * (maxStepWidth - minStepWidth);

    redrawAllNotes();
    updateTimelineGrids();
    updateAllTimelineWidths();
}


function updateTempo() {
    let newTempo = parseFloat(document.getElementById('tempoInput').value);
    if (!newTempo || newTempo <= 0) newTempo = 1;

    const oldTempo = tempo;
    const incompatibleNotes = [];
    const epsilon = 0.00001; // To handle floating point inaccuracies

    // No need to check if new tempo is a multiple of the old one
    if (newTempo > oldTempo && newTempo % oldTempo === 0) {
        tempo = newTempo;
        redrawAllNotes();
        saveState();
        return;
    }

    tracks.forEach(track => {
        track.notes.forEach(note => {
            const startCheck = note.start * newTempo;
            const durationCheck = note.duration * newTempo;
            const startIncompatible = Math.abs(startCheck - Math.round(startCheck)) > epsilon;
            const durationIncompatible = Math.abs(durationCheck - Math.round(durationCheck)) > epsilon;
            if (startIncompatible || durationIncompatible) {
                incompatibleNotes.push({note, startIncompatible, durationIncompatible});
            }
        });
    });

    if (incompatibleNotes.length > 0) {
        const choice = prompt("Some notes are not aligned with the new tempo. Choose an action:\n'u' - round up\n'd' - round down\n'k' - keep as is");

        if (choice === null) {
            document.getElementById('tempoInput').value = oldTempo;
            return; // Abort tempo change
        }

        const processedChoice = choice.toLowerCase();

        switch (processedChoice) {
            case 'u':
                incompatibleNotes.forEach(({note, startIncompatible, durationIncompatible}) => {
                    if (startIncompatible) {
                        note.start = Math.ceil(note.start * newTempo) / newTempo;
                    }
                    if (durationIncompatible) {
                        note.duration = Math.ceil(note.duration * newTempo) / newTempo;
                    }
                });
                break;
            case 'd':
                incompatibleNotes.forEach(({note, startIncompatible, durationIncompatible}) => {
                    if (startIncompatible) {
                        note.start = Math.floor(note.start * newTempo) / newTempo;
                    }
                    if (durationIncompatible) {
                        let newDuration = Math.floor(note.duration * newTempo) / newTempo;
                        if (newDuration < 0.01) newDuration = 0.01;
                        note.duration = newDuration;
                    }
                });
                break;
            case 'k':
                // Do nothing, just apply the new tempo
                break;
            default:
                document.getElementById('tempoInput').value = oldTempo;
                return; // Abort on invalid input
        }
    }

    tempo = newTempo;
    redrawAllNotes();
    updateTimelineGrids();
    saveState();
}

function redrawAllNotes() {
    tracks.forEach(track => {
        track.notes.forEach(note => {
            note.elements.forEach(el => {
                el.style.left = (note.start * stepWidth) + 'px';
                el.style.width = (note.duration * stepWidth) + 'px';
            });
        });
    });
}

function addTrack(sourceTrack = null, skipNoteCreation = false, suppressSave = false) {
    trackCount++;
    let track = { name: '', notes: [], isLinked: false, color: getNextColor(), groupId: null };
    if (sourceTrack) {
        track.name = sourceTrack.name;
        track.groupId = sourceTrack.groupId;
        if (!skipNoteCreation) {
            track.notes = sourceTrack.notes.map(n => ({ start: n.start, duration: n.duration, elements: [] }));
        }
    } else {
        track.groupId = Date.now() + Math.random();
    }
    tracks.push(track);
    createTrackRow(track);
    if (sourceTrack && !skipNoteCreation) {
        track.notes.forEach(note => createNoteElement(track, note));
    }

    let tbody = document.querySelector('#music-table tbody');
    tbody.appendChild(track.elem);

    updateTrackLabels();
    updateTrackStyles();
    updateTrackColors();
    if (!suppressSave) saveState();
    return track;
}

function createTrackRow(track) {
    let tbody = document.querySelector('#music-table tbody');
    let tr = document.createElement('tr');

    let tdInstrument = document.createElement('td');
    let instrCol = document.createElement('div');
    instrCol.className = 'instrument-col';

    let dragHandle = document.createElement('span');
    dragHandle.className = 'drag-handle';
    dragHandle.textContent = 'â˜°';
    dragHandle.addEventListener('mousedown', dragStart);
    instrCol.appendChild(dragHandle);

    let label = document.createElement('span');
    label.className = 'track-label';
    label.textContent = 'Track ' + trackCount;
    let input = document.createElement('input');
    input.type = 'text';
    input.placeholder = 'Instrument name';
    input.value = track.name;
    input.addEventListener('input', () => { 
        track.name = input.value; 
        saveState();
    });

    let trackLabelInputContainer = document.createElement('div');
    trackLabelInputContainer.className = 'track-label-input-container';
    trackLabelInputContainer.appendChild(label);
    trackLabelInputContainer.appendChild(input);

    let linkBtn = document.createElement('button');
    linkBtn.textContent = 'Link';
    linkBtn.className = 'link-btn';
    let unlinkBtn = document.createElement('button');
    unlinkBtn.textContent = 'Unlink';
    unlinkBtn.className = 'unlink-btn';
    let dupBtn = document.createElement('button');
    dupBtn.textContent = 'Duplicate';
    let delBtn = document.createElement('button');
    delBtn.textContent = 'Delete';

    let colorInput = document.createElement('input');
    colorInput.type = 'color';
    if (!track.color) {
        track.color = getNextColor();
    }
    colorInput.value = track.color;
    colorInput.addEventListener('input', () => {
        track.color = colorInput.value;
        updateTrackColors();
        saveState();
    });

    instrCol.appendChild(trackLabelInputContainer);
    instrCol.appendChild(colorInput);
    instrCol.appendChild(linkBtn);
    instrCol.appendChild(unlinkBtn);
    instrCol.appendChild(dupBtn);
    instrCol.appendChild(delBtn);
    tdInstrument.appendChild(instrCol);
    tr.appendChild(tdInstrument);

    let tdTimeline = document.createElement('td');
    let timeline = document.createElement('div');
    timeline.className = 'timeline-col';
    timeline.style.minWidth = '1000px'; // initial width
    timeline.addEventListener('click', (e) => {
        if (isDraggingOrResizing) return;
        if (e.target.classList.contains('note') || e.target.classList.contains('resize-handle')) return;
        
        let rect = timeline.getBoundingClientRect();
        let x = e.clientX - rect.left;

        for (const note of track.notes) {
            const noteStartPx = note.start * stepWidth;
            const noteEndPx = (note.start + note.duration) * stepWidth;
            if (x >= noteStartPx && x <= noteEndPx) {
                return;
            }
        }

        let step = Math.floor((Math.round(x / (stepWidth / tempo)) / tempo) * 100) / 100;
        if (step < 0) step = 0;

        if (track.notes.some(n => n.start === step)) return;

        let min_duration = Math.floor((1/tempo) * 100) / 100;
        if (min_duration <= 0) min_duration = 0.01;
        let durationInput = prompt('Enter duration (in steps):', min_duration.toString());

        if (durationInput === null) {
            return;
        }

        let duration = Math.floor(parseFloat(durationInput) * 100) / 100;
        if (isNaN(duration) || duration < min_duration) {
            duration = min_duration;
        }

        for (let i = 0; i < track.notes.length; i++) {
            let n = track.notes[i];
            if (step < n.start + n.duration && step + duration > n.start) {
                if (step < n.start) {
                    duration = n.start - step;
                } else {
                    return; 
                }
                break;
            }
        }

        let note = { start: step, duration: duration, elements: [] };
        track.notes.push(note);

        tracks.forEach(tr => {
            if (tr.notes === track.notes) {
                createNoteElement(tr, note);
            }
        });
        updateTimelineWidth(track);
        saveState();
    });
    tdTimeline.appendChild(timeline);
    tr.appendChild(tdTimeline);

    tbody.appendChild(tr);
    track.elem = tr;
    track.timeline = timeline;
    track.input = input;
    track.label = label;

    dupBtn.addEventListener('click', () => addTrack(track));
    delBtn.addEventListener('click', () => {
        if (!track.isLinked) {
            const myIndex = tracks.indexOf(track);
            const childrenToUnlink = [];
            for (let i = myIndex + 1; i < tracks.length; i++) {
                const nextTrack = tracks[i];
                if (nextTrack.notes === track.notes && nextTrack.isLinked) {
                    childrenToUnlink.push(nextTrack);
                } else {
                    break;
                }
            }

            if (childrenToUnlink.length > 0) {
                const firstChild = childrenToUnlink[0];
                firstChild.isLinked = false;
                childrenToUnlink.slice(1).forEach(child => {
                    child.notes = firstChild.notes;
                });
            }
        }

        let idx = tracks.indexOf(track);
        if (idx !== -1) {
            tracks.splice(idx, 1);
            track.elem.remove();
            updateTrackLabels();
            updateTrackStyles();
            saveState();
        }
    });
    linkBtn.addEventListener('click', () => {
        let originalIndex = tracks.indexOf(track);
        let newTrack = addTrack(track, true, true);
        newTrack.groupId = track.groupId;

        tracks.splice(tracks.indexOf(newTrack), 1);
        tracks.splice(originalIndex + 1, 0, newTrack);

        newTrack.isLinked = true;
        newTrack.color = track.color;
        newTrack.notes = track.notes;

        newTrack.notes.forEach(note => createNoteElement(newTrack, note));

        let tbody = document.querySelector('#music-table tbody');
        tracks.forEach(t => tbody.appendChild(t.elem));

        updateTrackLabels();
        updateTrackStyles();
        updateTrackColors();
        saveState();
    });

    unlinkBtn.addEventListener('click', () => {
        const notesRef = track.notes;
        const linkedGroup = tracks.filter(t => t.notes === notesRef);
        const lastTrackOfGroup = linkedGroup[linkedGroup.length - 1];

        track.isLinked = false;
        track.notes = track.notes.map(n => ({ ...n, elements: [] }));
        track.color = getNextColor();
        track.groupId = Date.now() + Math.random();
        
        track.timeline.innerHTML = '';
        track.notes.forEach(note => createNoteElement(track, note));

        const currentIndex = tracks.indexOf(track);
        tracks.splice(currentIndex, 1);
        const newIndex = tracks.indexOf(lastTrackOfGroup);
        tracks.splice(newIndex + 1, 0, track);

        let tbody = document.querySelector('#music-table tbody');
        tracks.forEach(t => tbody.appendChild(t.elem));

        updateTrackLabels();
        updateTrackStyles();
        updateTrackColors();
        saveState();
    });
}

function updateTrackLabels() {
    tracks.forEach((track, i) => {
        track.label.textContent = 'Track ' + (i+1);
    });
}

function createNoteElement(track, note) {
    let tl = track.timeline;
    let div = document.createElement('div');
    div.className = 'note';
    div.style.backgroundColor = track.color;
    div.style.left = (note.start * stepWidth) + 'px';
    div.style.width = (note.duration * stepWidth) + 'px';
    div.noteData = note;

    let leftHandle = document.createElement('div');
    leftHandle.className = 'resize-handle left';
    div.appendChild(leftHandle);

    let rightHandle = document.createElement('div');
    rightHandle.className = 'resize-handle right';
    div.appendChild(rightHandle);

    div.addEventListener('mousedown', onMouseDownNote);
    leftHandle.addEventListener('mousedown', onMouseDownLeftHandle);
    rightHandle.addEventListener('mousedown', onMouseDownRightHandle);

    let del = document.createElement('span');
    del.className = 'delete-note';
    del.textContent = 'Ã—';
    del.addEventListener('click', (e) => {
        e.stopPropagation();
        let arr = track.notes;
        let idx = arr.indexOf(note);
        if (idx > -1) arr.splice(idx, 1);
        note.elements.forEach(el => el.remove());
        note.elements = [];

        const linkedGroup = tracks.filter(t => t.notes === arr);
        linkedGroup.forEach(updateTimelineWidth);

        saveState();
    });

    div.addEventListener('click', (e) => {
        e.stopPropagation();
    });

    div.appendChild(del);

    let edit = document.createElement('span');
    edit.className = 'edit-note';
    edit.textContent = 'âœŽ';
    edit.addEventListener('click', (e) => {
        e.stopPropagation();
        let min_duration = Math.floor((1/tempo) * 100) / 100;
        if (min_duration <= 0) min_duration = 0.01;
        let newDur = prompt('Edit duration (in steps):', note.duration);
        if (newDur === null) return;

        let nd = Math.floor(parseFloat(newDur) * 100) / 100;
        if (isNaN(nd) || nd < min_duration) {
            nd = min_duration;
        }

        for (let i = 0; i < track.notes.length; i++) {
            let n = track.notes[i];
            if (n !== note && note.start < n.start + n.duration && note.start + nd > n.start) {
                nd = n.start - note.start;
                if (nd < min_duration) nd = min_duration;
                break;
            }
        }
        note.duration = nd;
        
        note.elements.forEach(el => {
            el.style.width = (note.duration * stepWidth) + 'px';
        });

        updateTimelineWidth(track);
        saveState();
    });
    div.appendChild(edit);
    tl.appendChild(div);
    note.elements = note.elements || [];
    note.elements.push(div);
    return div;
}function updateTrackStyles() {
    tracks.forEach(track => {
        if (track.elem) {
            if (track.isLinked) {
                track.elem.classList.add('indented');
            } else {
                track.elem.classList.remove('indented');
            }
        }
    });
}

const pastelColors = [
    'hsl(24, 100%, 85%)', 'hsl(43, 100%, 85%)', 'hsl(62, 100%, 85%)',
    'hsl(81, 100%, 85%)', 'hsl(100, 100%, 85%)', 'hsl(119, 100%, 85%)',
    'hsl(138, 100%, 85%)', 'hsl(157, 100%, 85%)', 'hsl(176, 100%, 85%)',
    'hsl(195, 100%, 85%)', 'hsl(214, 100%, 85%)', 'hsl(233, 100%, 85%)',
    'hsl(252, 100%, 85%)', 'hsl(271, 100%, 85%)', 'hsl(290, 100%, 85%)',
    'hsl(309, 100%, 85%)', 'hsl(328, 100%, 85%)', 'hsl(347, 100%, 85%)'
];
let colorIndex = 0;

const hslToHex = (h, s, l) => {
  l /= 100;
  const a = s * Math.min(l, 1 - l) / 100;
  const f = n => {
    const k = (n + h / 30) % 12;
    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return Math.round(255 * color).toString(16).padStart(2, '0');
  };
  return `#${f(0)}${f(8)}${f(4)}`;
};

function getNextColor() {
    const colorHsl = pastelColors[colorIndex];
    const [h, s, l] = colorHsl.match(/\d+/g).map(Number);
    colorIndex = (colorIndex + 1) % pastelColors.length;
    return hslToHex(h, s, l);
}

function updateTrackColors() {
    const colorGroups = {};
    tracks.forEach(track => {
        if (!colorGroups[track.groupId]) {
            colorGroups[track.groupId] = [];
        }
        colorGroups[track.groupId].push(track);
    });

    for (let key in colorGroups) {
        const group = colorGroups[key];
        const parentColor = group[0].color;
        group.forEach(track => {
            track.color = parentColor;
            if (track.elem) {
                const instrumentTd = track.elem.querySelector('td');
                if (instrumentTd) {
                    instrumentTd.style.backgroundColor = track.color;
                }
                const colorInput = track.elem.querySelector('input[type="color"]');
                if (colorInput) {
                    colorInput.value = track.color;
                }
                track.notes.forEach(note => {
                    note.elements.forEach(noteEl => {
                        if (noteEl) {
                            noteEl.style.backgroundColor = track.color;
                        }
                    });
                });
            }
        });
    }
}

function updateTimelineWidth(track) {
    if (!track.notes || track.notes.length === 0) {
        track.timeline.style.minWidth = '1000px'; // Default width
        return;
    }
    const maxEnd = Math.max(0, ...track.notes.map(n => n.start + n.duration));
    track.timeline.style.minWidth = (maxEnd * stepWidth + 200) + 'px';
}

function updateAllTimelineWidths() {
    tracks.forEach(updateTimelineWidth);
}

function updateTimelineGrids() {
    const gridWidth = stepWidth / tempo;
    tracks.forEach(track => {
        track.timeline.style.backgroundSize = `${gridWidth}px 100%, 100% 21px`;
    });
}

function updateZoom() {
    const slider = document.getElementById('zoomSlider');
    zoomLevel = parseInt(slider.value, 10);

    const minStepWidth = 8.33; // Represents ~1 minute of music at 120bpm in a 1000px view
    const maxStepWidth = 100;  // Represents 0.01 units as 1px

    stepWidth = minStepWidth + (zoomLevel / 100) * (maxStepWidth - minStepWidth);

    redrawAllNotes();
    updateTimelineGrids();
    updateAllTimelineWidths();
}

document.getElementById('zoomSlider').addEventListener('input', updateZoom);


let currentlyDragging = null;
let draggingGroup = [];
let isDraggingOrResizing = false;

function dragStart(e) {
    isDraggingOrResizing = true;
    const startTr = this.closest('tr');
    const startTrack = tracks.find(t => t.elem === startTr);
    if (!startTrack) return;

    // Determine the parent of the group
    let parentTrack;
    if (startTrack.isLinked) {
        const notesRef = startTrack.notes;
        parentTrack = tracks.find(t => !t.isLinked && t.notes === notesRef);
    } else {
        parentTrack = startTrack;
    }

    if (!parentTrack) return;

    // The drag is anchored to the parent
    currentlyDragging = parentTrack.elem;
    draggingGroup = [parentTrack.elem];

    // Find all children of that parent
    const startIndex = tracks.indexOf(parentTrack);
    for (let i = startIndex + 1; i < tracks.length; i++) {
        const nextTrack = tracks[i];
        if (nextTrack.isLinked && nextTrack.notes === parentTrack.notes) {
            draggingGroup.push(nextTrack.elem);
        } else {
            break;
        }
    }

    // Apply styling to the whole group
    draggingGroup.forEach(tr => {
        tr.style.opacity = 0.5;
        tr.classList.add('dragging');
    });

    document.addEventListener('mousemove', dragOver);
    document.addEventListener('mouseup', dragEnd);
}

function dragOver(e) {
    if (!currentlyDragging) return;
    const tbody = currentlyDragging.parentElement;
    // Find the next row that isn't part of the group we're dragging
    const allRows = [...tbody.querySelectorAll('tr:not(.dragging)')];
    let nextRow = allRows.find(row => {
        const rowRect = row.getBoundingClientRect();
        return e.clientY < rowRect.top + rowRect.height / 2;
    });

    // If we are about to drop inside a linked group, find the parent of that group and drop before it.
    if (nextRow) {
        const nextTrack = tracks.find(t => t.elem === nextRow);
        if (nextTrack && nextTrack.isLinked) {
            const notesRef = nextTrack.notes;
            // Find the parent of this group.
            const parentTrack = tracks.find(t => !t.isLinked && t.notes === notesRef);
            if (parentTrack) {
                nextRow = parentTrack.elem;
            }
        }
    }

    // Move the entire group
    if (nextRow) {
        draggingGroup.forEach(tr => tbody.insertBefore(tr, nextRow));
    } else {
        draggingGroup.forEach(tr => tbody.appendChild(tr));
    }
}

function dragEnd() {
    if (!currentlyDragging) return;

    // Reset styles for the group
    draggingGroup.forEach(tr => {
        tr.style.opacity = 1;
        tr.classList.remove('dragging');
    });

    // Update the tracks array to match the new DOM order
    const tbody = currentlyDragging.parentElement;
    const newOrderedElems = [...tbody.querySelectorAll('tr')];
    tracks = newOrderedElems.map(elem => {
        return tracks.find(t => t.elem === elem);
    });

    document.removeEventListener('mousemove', dragOver);
    document.removeEventListener('mouseup', dragEnd);
    currentlyDragging = null;
    draggingGroup = [];

    // Update labels to reflect new order
    updateTrackLabels();
    updateTrackColors();
    
    // Use a timeout to reset the flag after the click event has had time to fire and be ignored.
    setTimeout(() => { 
        isDraggingOrResizing = false; 
        saveState();
    }, 0);
}

let activeNote = null;
let activeTrack = null;
let initialX = 0;
let initialLeft = 0;
let initialWidth = 0;

function onMouseDownNote(e) {
    if (e.target.classList.contains('resize-handle')) return;
    e.preventDefault();
    isDraggingOrResizing = true;
    activeNote = this;
    activeTrack = tracks.find(t => t.timeline === this.parentElement);
    initialX = e.clientX;
    initialLeft = this.offsetLeft;
    document.addEventListener('mousemove', onMouseMoveNote);
    document.addEventListener('mouseup', onMouseUpNote);
}

function onMouseMoveNote(e) {
    if (!activeNote) return;

    // Auto-expand timeline
    const timeline = activeTrack.timeline;
    const timelineRect = timeline.getBoundingClientRect();
    if (e.clientX > timelineRect.right - 200) {
        timeline.style.minWidth = (timeline.offsetWidth + window.innerWidth) + 'px';
    }

    let dx = e.clientX - initialX;
    let newLeft = initialLeft + dx;
    let newStart = Math.round(newLeft / stepWidth * tempo) / tempo;

    const snapThreshold = 0.5; // Snap within 0.5 steps
    let closestPrevNoteEnd = -Infinity;
    let closestNextNoteStart = Infinity;

    // Find the closest notes
    for (const n of activeTrack.notes) {
        if (n === activeNote.noteData) continue;
        if (n.start + n.duration > closestPrevNoteEnd && n.start < newStart) {
            closestPrevNoteEnd = n.start + n.duration;
        }
        if (n.start < closestNextNoteStart && n.start > newStart) {
            closestNextNoteStart = n.start;
        }
    }

    // Snap to the end of the previous note
    if (Math.abs(newStart - closestPrevNoteEnd) < snapThreshold) {
        newStart = closestPrevNoteEnd;
    } 
    // Snap to the start of the next note
    else if (Math.abs((newStart + activeNote.noteData.duration) - closestNextNoteStart) < snapThreshold) {
        newStart = closestNextNoteStart - activeNote.noteData.duration;
    }

    newLeft = newStart * stepWidth;

    // Update all linked note elements' positions simultaneously
    activeNote.noteData.elements.forEach(el => {
        el.style.left = newLeft + 'px';
    });
}

function onMouseUpNote(e) {
    if (!activeNote) return;
    let newLeft = activeNote.offsetLeft;
    let newStart = Math.round(newLeft / stepWidth * tempo) / tempo;
    if (newStart < 0) newStart = 0;

    let collidingNotes = [];
    for (let i = 0; i < activeTrack.notes.length; i++) {
        let n = activeTrack.notes[i];
        if (n !== activeNote.noteData && newStart < n.start + n.duration && newStart + activeNote.noteData.duration > n.start) {
            collidingNotes.push(n);
        }
    }

    if (collidingNotes.length > 0) {
        const minStart = Math.min(...collidingNotes.map(n => n.start));
        const maxEnd = Math.max(...collidingNotes.map(n => n.start + n.duration));

        const draggedNoteCenter = newStart + activeNote.noteData.duration / 2;
        const collisionBlockCenter = (minStart + maxEnd) / 2;

        let potentialStarts = [];
        if (draggedNoteCenter < collisionBlockCenter) {
            potentialStarts.push(minStart - activeNote.noteData.duration);
            potentialStarts.push(maxEnd);
        } else {
            potentialStarts.push(maxEnd);
            potentialStarts.push(minStart - activeNote.noteData.duration);
        }

        let finalStart = -1;

        for (const start of potentialStarts) {
            if (start < 0) continue;
            let isPossible = true;
            for (const n of activeTrack.notes) {
                if (n !== activeNote.noteData && start < n.start + n.duration && start + activeNote.noteData.duration > n.start) {
                    isPossible = false;
                    break;
                }
            }
            if (isPossible) {
                finalStart = start;
                break;
            }
        }

        if (finalStart !== -1) {
            newStart = finalStart;
        } else {
            newStart = activeNote.noteData.start;
        }
    }

    activeNote.noteData.start = Math.round(newStart * 100) / 100;
    
    // Update all linked note elements
    activeNote.noteData.elements.forEach(el => {
        el.style.left = (activeNote.noteData.start * stepWidth) + 'px';
    });

    // Extend timeline width if needed
    updateTimelineWidth(activeTrack);

    document.removeEventListener('mousemove', onMouseMoveNote);
    document.removeEventListener('mouseup', onMouseUpNote);
    activeNote = null;
    activeTrack = null;
    setTimeout(() => { 
        isDraggingOrResizing = false; 
        saveState();
    }, 0);
}

function onMouseDownLeftHandle(e) {
    e.stopPropagation();
    e.preventDefault();
    isDraggingOrResizing = true;
    activeNote = this.parentElement;
    activeTrack = tracks.find(t => t.timeline === this.parentElement.parentElement);
    initialX = e.clientX;
    initialLeft = activeNote.offsetLeft;
    initialWidth = activeNote.offsetWidth;
    let tooltip = document.getElementById('duration-tooltip');
    tooltip.style.display = 'block';
    document.addEventListener('mousemove', onMouseMoveLeftHandle);
    document.addEventListener('mouseup', onMouseUpLeftHandle);
}

function onMouseMoveLeftHandle(e) {
    if (!activeNote) return;

    // Auto-expand timeline
    const timeline = activeTrack.timeline;
    const timelineRect = timeline.getBoundingClientRect();
    if (e.clientX > timelineRect.right - 200) {
        timeline.style.minWidth = (timeline.offsetWidth + window.innerWidth) + 'px';
    }

    let dx = e.clientX - initialX;
    let newLeft = initialLeft + dx;
    let newWidth = initialWidth - dx;
    let newStart = Math.round(newLeft / (stepWidth / tempo)) / tempo;
    let newDuration = Math.round(newWidth / (stepWidth / tempo)) / tempo;

    // Find the closest note to the left
    let maxPrevEnd = -Infinity;
    for (const n of activeTrack.notes) {
        if (n !== activeNote.noteData && n.start < activeNote.noteData.start && n.start + n.duration > maxPrevEnd) {
            maxPrevEnd = n.start + n.duration;
        }
    }

    // If we are resizing past the closest note, snap to it.
    if (newStart < maxPrevEnd) {
        newStart = maxPrevEnd;
        newDuration = (activeNote.noteData.start + activeNote.noteData.duration) - newStart;
        newLeft = newStart * stepWidth;
        newWidth = newDuration * stepWidth;
    }

    // Update all linked note elements' positions and widths simultaneously
    activeNote.noteData.elements.forEach(el => {
        el.style.left = newLeft + 'px';
        el.style.width = newWidth + 'px';
    });

    let tooltip = document.getElementById('duration-tooltip');
    tooltip.textContent = newDuration.toFixed(2);
    tooltip.style.left = (e.clientX + 15) + 'px';
    tooltip.style.top = (e.clientY + 15) + 'px';
}

function onMouseUpLeftHandle(e) {
    if (!activeNote) return;
    let newLeft = activeNote.offsetLeft;
    let newWidth = activeNote.offsetWidth;
    let newStart = Math.round(newLeft / stepWidth * tempo) / tempo;
    let newDuration = Math.round(newWidth / stepWidth * tempo) / tempo;
    if (newStart < 0) newStart = 0;
    let min_duration = 1/tempo;
    if (newDuration < min_duration) newDuration = min_duration;

    const originalEnd = activeNote.noteData.start + activeNote.noteData.duration;

    // Collision detection
    for (let i = 0; i < activeTrack.notes.length; i++) {
        let n = activeTrack.notes[i];
        if (n !== activeNote.noteData && newStart < n.start + n.duration && newStart + newDuration > n.start) {
            newStart = n.start + n.duration;
            newDuration = originalEnd - newStart;
            if (newDuration < min_duration) {
                newDuration = min_duration;
                newStart = originalEnd - min_duration;
            }
            break;
        }
    }

    activeNote.noteData.start = newStart;
    activeNote.noteData.duration = newDuration;

    // Update all linked note elements
    activeNote.noteData.elements.forEach(el => {
        el.style.left = (newStart * stepWidth) + 'px';
        el.style.width = (newDuration * stepWidth) + 'px';
    });

    // Extend timeline width if needed
    updateTimelineWidth(activeTrack);

    let tooltip = document.getElementById('duration-tooltip');
    tooltip.style.display = 'none';

    document.removeEventListener('mousemove', onMouseMoveLeftHandle);
    document.removeEventListener('mouseup', onMouseUpLeftHandle);
    activeNote = null;
    activeTrack = null;
    setTimeout(() => { 
        isDraggingOrResizing = false; 
        saveState();
    }, 0);
}

function onMouseDownRightHandle(e) {
    e.stopPropagation();
    e.preventDefault();
    isDraggingOrResizing = true;
    activeNote = this.parentElement;
    activeTrack = tracks.find(t => t.timeline === this.parentElement.parentElement);
    initialX = e.clientX;
    initialWidth = activeNote.offsetWidth;
    let tooltip = document.getElementById('duration-tooltip');
    tooltip.style.display = 'block';
    document.addEventListener('mousemove', onMouseMoveRightHandle);
    document.addEventListener('mouseup', onMouseUpRightHandle);
}

function onMouseMoveRightHandle(e) {
    if (!activeNote) return;

    // Auto-expand timeline
    const timeline = activeTrack.timeline;
    const timelineRect = timeline.getBoundingClientRect();
    if (e.clientX > timelineRect.right - 200) {
        timeline.style.minWidth = (timeline.offsetWidth + window.innerWidth) + 'px';
    }

    let dx = e.clientX - initialX;
    let newWidth = initialWidth + dx;
    let newDuration = Math.round(newWidth / (stepWidth / tempo)) / tempo;

    // Find the closest note to the right
    let minNextStart = Infinity;
    for (const n of activeTrack.notes) {
        if (n !== activeNote.noteData && n.start > activeNote.noteData.start && n.start < minNextStart) {
            minNextStart = n.start;
        }
    }

    // If we are resizing past the closest note, snap to it.
    if (activeNote.noteData.start + newDuration > minNextStart) {
        newDuration = minNextStart - activeNote.noteData.start;
        newWidth = newDuration * stepWidth;
    }

    // Update all linked note elements' widths simultaneously
    activeNote.noteData.elements.forEach(el => {
        el.style.width = newWidth + 'px';
    });

    let tooltip = document.getElementById('duration-tooltip');
    tooltip.textContent = newDuration.toFixed(2);
    tooltip.style.left = (e.clientX + 15) + 'px';
    tooltip.style.top = (e.clientY + 15) + 'px';
}

function onMouseUpRightHandle(e) {
    if (!activeNote) return;
    let newWidth = activeNote.offsetWidth;
    let newDuration = Math.round(newWidth / stepWidth * tempo) / tempo;
    let min_duration = 1/tempo;
    if (newDuration < min_duration) newDuration = min_duration;

    // Collision detection
    for (let i = 0; i < activeTrack.notes.length; i++) {
        let n = activeTrack.notes[i];
        if (n !== activeNote.noteData && activeNote.noteData.start < n.start + n.duration && activeNote.noteData.start + newDuration > n.start) {
            newDuration = n.start - activeNote.noteData.start;
            if (newDuration < min_duration) newDuration = min_duration;
            break;
        }
    }

    activeNote.noteData.duration = newDuration;
    
    // Update all linked note elements
    activeNote.noteData.elements.forEach(el => {
        el.style.width = (newDuration * stepWidth) + 'px';
    });

    // Extend timeline width if needed
    updateTimelineWidth(activeTrack);

    let tooltip = document.getElementById('duration-tooltip');
    tooltip.style.display = 'none';

    document.removeEventListener('mousemove', onMouseMoveRightHandle);
    document.removeEventListener('mouseup', onMouseUpRightHandle);
    activeNote = null;
    activeTrack = null;
    setTimeout(() => { 
        isDraggingOrResizing = false; 
        saveState();
    }, 0);
}

function exportTracks() {
    if (tracks.length === 0) {
        alert('No tracks to export.');
        return;
    }

    let allNotes = [];
    const allStartTimes = new Set();

    tracks.forEach(track => {
        if (track.name.trim() === '') {
            alert('All tracks must have an instrument name for export.');
            throw new Error("Missing instrument name.");
        }
        track.notes.forEach(note => {
            allNotes.push({
                instrument: track.name,
                duration: note.duration,
                start: note.start,
            });
            allStartTimes.add(note.start);
        });
    });

    if (allNotes.length === 0) {
        alert('No notes to export.');
        return;
    }

    let exportData = '';
    let lastTime = 0;
    const sortedStartTimes = Array.from(allStartTimes).sort((a, b) => a - b);
    let notesCount = 0;

    for (const time of sortedStartTimes) {
        const notesAtTime = allNotes.filter(note => Math.abs(note.start - time) < 0.001);
        if (notesAtTime.length > 0) {
            if (time > lastTime) {
                const delay = time - lastTime;
                exportData += 'x,' + delay.toFixed(2) + ' ';
                notesCount++;
            }
            const notesString = notesAtTime.map(note => {
                return `${note.instrument},${note.duration.toFixed(2)}`;
            }).join(' ');
            exportData += notesString + ' ';
            notesCount += notesAtTime.length;

            if (notesCount >= 12) {
                exportData += '\n';
                notesCount = 0;
            }
            lastTime = time;
        }
    }

    let pasteContent = exportData.trim();
    const newTab = window.open();
    newTab.document.open();
    newTab.document.write(`
        <pre id="song-data">${pasteContent}</pre>
        <button id="downloadBtn">Download .song</button>
        <script>
            document.getElementById('downloadBtn').addEventListener('click', () => {
                const text = document.getElementById('song-data').textContent;
                const blob = new Blob([text], { type: 'text/plain' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'music.song';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            });
        <\/script>
    `);
    newTab.document.close();
}

function importTracks() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.song,text/plain';
    input.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = e => {
            const content = e.target.result;
            parseAndLoadSong(content);
        };
        reader.readAsText(file);
    };
    input.click();
}

function parseAndLoadSong(content) {
    const previousState = localStorage.getItem('musicMakerState');
    try {
        document.querySelector('#music-table tbody').innerHTML = '';
        tracks = [];
        trackCount = 0;

        const instrumentNotes = {};
        let currentTime = 0;
        const parts = content.trim().split(/\s+/);

        if (parts.length === 1 && parts[0] === '') {
            addTrack();
            return;
        }

        parts.forEach(part => {
            if (!part) return;
            const [instrument, value] = part.split(',');
            if (instrument === 'x') {
                const delay = parseFloat(value);
                if (isNaN(delay)) throw new Error(`Invalid delay value: ${value}`);
                currentTime += delay;
            } else {
                const duration = parseFloat(value);
                if (!instrument || value === undefined || isNaN(duration)) throw new Error(`Invalid note format: ${part}`);
                if (!instrumentNotes[instrument]) {
                    instrumentNotes[instrument] = [];
                }
                instrumentNotes[instrument].push({
                    start: currentTime,
                    duration: duration
                });
            }
        });

        const noteSequences = {};
        Object.keys(instrumentNotes).forEach(instrument => {
            const sequence = JSON.stringify(instrumentNotes[instrument]);
            if (!noteSequences[sequence]) {
                noteSequences[sequence] = [];
            }
            noteSequences[sequence].push(instrument);
        });

        if (Object.keys(noteSequences).length === 0) {
             addTrack(); // Add a default track if the file was valid but empty of notes
        }

        Object.values(noteSequences).forEach(instruments => {
            let parentTrack = null;
            instruments.forEach((instrumentName, index) => {
                if (index === 0) {
                    parentTrack = addTrack(null, false, true);
                    parentTrack.name = instrumentName;
                    parentTrack.input.value = instrumentName;
                    const notes = instrumentNotes[instrumentName];
                    notes.forEach(noteInfo => {
                        const note = { start: noteInfo.start, duration: noteInfo.duration, elements: [] };
                        parentTrack.notes.push(note);
                        createNoteElement(parentTrack, note);
                    });
                } else {
                    let newTrack = addTrack(parentTrack, true, true);
                    newTrack.name = instrumentName;
                    newTrack.input.value = instrumentName;
                    newTrack.groupId = parentTrack.groupId;

                    const originalIndex = tracks.indexOf(parentTrack);
                    tracks.splice(tracks.indexOf(newTrack), 1);
                    tracks.splice(originalIndex + 1, 0, newTrack);

                    newTrack.isLinked = true;
                    newTrack.color = parentTrack.color;
                    newTrack.notes = parentTrack.notes;

                    newTrack.notes.forEach(note => createNoteElement(newTrack, note));
                }
            });
        });

        const tbody = document.querySelector('#music-table tbody');
        tracks.forEach(t => tbody.appendChild(t.elem));

        updateTrackLabels();
        updateTrackStyles();
        updateTrackColors();
        redrawAllNotes();
        updateAllTimelineWidths();
        saveState();
    } catch (error) {
        alert('Error parsing file. Please ensure it is a valid .song file.\nYour previous work has been restored.');
        console.error('Import error:', error);
        if (previousState) {
            localStorage.setItem('musicMakerState', previousState);
        } else {
            localStorage.removeItem('musicMakerState');
        }
        location.reload();
    }
}

loadState();
</script>
</body>
</html>